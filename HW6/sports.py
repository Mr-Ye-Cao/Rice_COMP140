"""
Sports Analytics
"""

import numeric
import math
import codeskulptor
from urllib import request
import comp140_module6 as sports

def read_matrix(filename):
    """
    Parse data from the file with the given filename into a matrix.

    input:
        - filename: a string representing the name of the file

    returns: a matrix containing the elements in the given file
    """
    # convert filename into url format
    url = codeskulptor.file2url(filename)
    
    # open the file
    netfile = request.urlopen(url)
    
    #initiate a list to create later matrix
    mlst = []
    
    # read binary file line by line
    for line in netfile.readlines():
        strline = line.decode('utf-8')
        print(strline.split(', '))
        row = [float(num) for num in strline[:-1].split(', ')]
        mlst.append(row)
    
    return numeric.Matrix(mlst)

#print(read_matrix("comp140_analytics_simple_matrix.txt"))

class LinearModel:
    """
    A class used to represent a Linear statistical
    model of multiple variables. This model takes
    a vector of input variables and predicts that
    the measured variable will be their weighted sum.
    """

    def __init__(self, weights):
        """
        Create a new LinearModel.

        inputs:
            - weights: an m x 1 matrix of weights
        """
        self._weights = weights

    def __str__(self):
        """
        Return: weights as a human readable string.
        """
        return str(self._weights)

    def get_weights(self):
        """
        Return: the weights associated with the model.
        """
        return self._weights

    def generate_predictions(self, inputs):
        """
        Use this model to predict a matrix of
        measured variables given a matrix of input data.

        inputs:
            - inputs: an n x m matrix of explanatory variables

        Returns: an n x 1 matrix of predictions
        """
        return inputs @ self.get_weights()

    def prediction_error(self, inputs, actual_result):
        """
        Calculate the MSE between the actual measured
        data and the predictions generated by this model
        based on the input data.

        inputs:
            - inputs: inputs: an n x m matrix of explanatory variables
            - actual_result: an n x 1 matrix of the corresponding
                             actual values for the measured variables

        Returns: a float that is the MSE between the generated
        data and the actual data
        """
        # this is the predicted result
        predict_result = self.generate_predictions(inputs)
        
        # use varible tsqe to record total error
        tsqe = 0
        
        # find the value of numcol
        numcol = predict_result.shape()[0]
        
        # parse over the actual_result and predicted_reult
        for idx in range(numcol):
            # update the difference of mean
            tsqe += (predict_result[(idx, 0)] - actual_result[(idx, 0)])**2    
        
        # return the mean square error
        return tsqe/numcol
    

def fit_least_squares(input_data, output_data):
    """
    Create a Linear Model which predicts the output vector
    given the input matrix with minimal Mean-Squared Error.

    inputs:
        - input_data: an n x m matrix
        - output_data: an n x 1 matrix

    returns: a LinearModel object which has been fit to approximately
    match the data
    """
    # w = [(X^T * X)^-1]^T * X^T * y (Math credit given to Freda)
    mat_wei = (input_data.transpose() @ input_data)
    mat_wei = mat_wei.inverse().transpose()
    mat_wei = mat_wei @ input_data.transpose()
    mat_wei = mat_wei @ output_data

    return LinearModel(mat_wei)

def softhreshold(numa, numb):
    """
    inputs: 
        - numa: number a for computation
        - numb: number b for computation
    outout:
        a - b if a > b
        0 if |a| <= b
        a + b if a < -b
    """
    result = -1
    if numa > numb:
        result = numa - numb
    elif numa**2 <= numb**2:
        result = 0
    elif numa < numb * -1:
        result = numa + numb
    return result

def fit_lasso(param, iterations, input_data, output_data):
    """
    Create a Linear Model which predicts the output vector
    given the input matrix using the LASSO method.

    inputs:
        - param: a float representing the lambda parameter
        - iterations: an integer representing the number of iterations
        - input_data: an n x m matrix
        - output_data: an n x 1 matrix

    returns: a LinearModel object which has been fit to approximately
    match the data
    """
    # first compute the orignal Mean Least Square
    wei_mat = fit_least_squares(input_data, output_data).get_weights()
    idx = 0
    num_col = input_data.shape()[1]

    while idx < iterations:
        wei_old = wei_mat.copy()
        for jdx in range(num_col):
            num_aj = (input_data.transpose() @ output_data)[(jdx, 0)]
            minv = (input_data.transpose() @ input_data).getrow(jdx)
            minv = (minv @ wei_mat)[(0, 0)]
            num_aj -= minv
            num_aj /= (input_data.transpose() @ input_data)[(jdx, jdx)]
            
            num_bj = param / (input_data.transpose() @ input_data)[(jdx, jdx)]
            num_bj /= 2
            wei_mat[(jdx, 0)] = softhreshold(wei_mat[(jdx, 0)] + num_aj, num_bj)

        if (wei_mat - wei_old).abs().summation() < 0.00001:
#            print(wei_old,wei_mat)
#            print((wei_mat - wei_old).summation())
#            print("yes")
            break

        idx += 1

    return LinearModel(wei_mat)

#print(fit_lasso(10, 2, numeric.Matrix([[1.0, 5.0], [2.0, 4.0]]), numeric.Matrix([[5.0], [20.0]])))

#def run_experiment(iterations):
    """
    Using some historical data from 1954-2000, as
    training data, generate weights for a Linear Model
    using both the Least-Squares method and the
    LASSO method (with several different lambda values).

    Test each of these models using the historical
    data from 2001-2012 as test data.

    inputs:
        - iterations: an integer representing the number of iterations to use

    Print out the model's prediction error on the two data sets
    """
 #   pass
